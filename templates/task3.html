{% extends 'header.html' %}
{% block task3 %}
    <style>
        /* General page styling */
        body {
/*            font-family: 'Poppins', sans-serif;*/
            background-color: #f9f9f9;
            color: #333;
        }

        .game-container {
            max-width: 600px;
            margin: 50px auto;
            text-align: center;
        }

        .card {
            background-color: #fff;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
/*            padding: 20px;*/
            margin-bottom: 20px;
            margin-top: 30px;
        }
                .icon-btn{
            background: none;
            border: none;
            color:white;
            font-size: 1.5rem;
        }
        .game-area {
            width: 100%;
            border-radius: 10px;
            background-color: #f1f1f1;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            box-sizing: border-box;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 10px;
        }

        .square {
            width: 100px;
            height: 100px;
            background-color: #ccc;
            border: 2px solid #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .square.active {
            background-color: yellow;
        }
.square.clicked {
    background-color: orange; /* Highlight color */
    transition: background-color 0.2s ease;
}

        #message {
/*            margin-top: 20px;*/
            font-size: 1.6rem;
            color: #007bff;
            margin-bottom:55px;
        }

        #start-btn {
            width: 150px;
            margin: 0 auto;
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #007bff;
            border: none;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2rem;
        }

        #start-btn:hover {
            background-color: #0056b3;
        }

        #break-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            text-align: center;
            color: #fff;
            font-size: 2rem;
            display: none;
        }

        #break-message p {
            background-color: #28a745;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
                .card-header {
            background-color: #007bff;
            color: white;
            padding: 15px;

            display: flex;
            justify-content: space-between;
            align-items:center;

            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
        }
/* Modernized card header */
.card-header {
    background: linear-gradient(135deg, #4f46e5, #3b82f6); /* Modern gradient */
    color: #ffffff;
    padding: 20px;
    font-size: 1.8rem;
    font-weight: 700;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid rgba(255, 255, 255, 0.2);
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(5px);
    position: relative;
    overflow: hidden;
}

.card-header::before {
    content: '';
    position: absolute;
    top: 0;
    left: -50px;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.3), transparent);
    transform: rotate(45deg);
    z-index: 0;
    pointer-events: none;
}

.card-header h2 {
    margin: 0;
    z-index: 1;
}

button.icon-btn {
    font-size: 1.8rem;
    color: #ffffff;
    background: none;
    border: none;
    cursor: pointer;
    transition: transform 0.2s, color 0.2s;
    z-index: 1;
}

button.icon-btn:hover {
    transform: scale(1.1);
    color: #c7d2fe;
}

#start-btn {
    width: 150px;
    margin: 0 auto;
    margin-top: 20px;
    padding: 10px 20px;
    background: linear-gradient(135deg, #3b82f6, #2563eb);
    border: none;
    color: #ffffff;
    border-radius: 10px;
    cursor: pointer;
    font-size: 1.2rem;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    transition: background 0.3s ease, transform 0.3s ease;
}

#start-btn:hover {
    background: #1e3a8a;
    transform: translateY(-2px);
}
    </style>

    <body>
        <div class="container">
<div class="modal fade" id="infoModal" tabindex="-1" aria-labelledby="infoModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Instructions for Task 3: Sequence Memory Task</h5>
            </div>


            <div class="modal-body">
                <p>In this task, you will see square grids. In each trial, squares will “light” up in a sequence. Your task is to click on the squares in the order they lit up once the sequence is over. The game will get more difficult as you progress, with larger grids in each round!</p>
                <ul>
                    <li>Round 1: Sequences in a 3x3 grid.</li>
                    <li>Round 2: Sequences in a 4x4 grid.</li>
                    <li>Round 3: Sequences in a 5x5 grid.</li>
                </ul>
                <p>How to play:</p>
                <ul>
                    <li>Watch the sequence carefully.</li>
                    <li>Once you see “Go!”, click the same squares in the same sequence.</li>
                    <li>The sequence can be up to 7 squares lighting up in order. </li>

                </ul>
                <p>Tip: Pay close attention to the sequence and try to remember the order as the grids become more complex!</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" id="start-task-btn">Start Task</button>
            </div>
        </div>
    </div>
</div>


        <div class="container game-container">
            <div class="card">
 <div class="card-header">
    <h2 id="task-header" class="text-center">Sequence Memory Task</h2>
</div>


<!--                <div id="message" class="text-center">Click the squares in the order they lit up.</div>-->
                <div class="game-area mb-5 mt-5">
                    <div class="grid" id="grid-container"></div>
                </div>
                <div id="message" class="text-center"></div>
<!--                <button type="button" id="start-btn" class="mb-4">Start Task</button>-->
            </div>

            <div id="break-message">
                <p>Next round starting in <span id="break-timer">5</span> seconds...</p>
            </div>
        </div>
        </div>
        <script>

            let sequence = [];
            let playerSequence = [];
            let round = 1;
            let mistakes = 0;
            const maxMistakes = 1;
let sequenceLength = 1; // Start with sequence length of 1
const trialsPerRound = 8; // Number of trials per round
let trial = 0; // Current trial counter
            const gridContainer = document.getElementById('grid-container');
            const message = document.getElementById('message');
//            const startButton = document.getElementById('start-btn');
            const breakMessage = document.getElementById('break-message');
            const breakTimerElement = document.getElementById('break-timer');

            let gridSize = 3;
            let level = 1;

//            startButton.addEventListener('click', startGame);
function activateSquare(index) {
    const square = document.getElementById(`square${index}`);
    if (square) {
        square.classList.add('active'); // Highlight the square
    }
}
function updateTaskHeader() {
    const taskHeader = document.getElementById('task-header');
    taskHeader.textContent = `Sequence Memory Task: Round ${level}`;
}

function deactivateSquare(index) {
    const square = document.getElementById(`square${index}`);
    if (square) {
        square.classList.remove('active'); // Remove the highlight
    }
}

function startGame() {
//    startButton.style.display = 'none';
    sequence = [];
    playerSequence = [];
    round = 1;
    mistakes = 0;
    updateMessage("Watch!");
    generateGrid(gridSize);
    nextRound();
}
function nextRound() {
    playerSequence = [];
    sequence = []; // Reset sequence for this trial

    let previousIndex = -1; // To keep track of the last index

    // Generate a new sequence of length `sequenceLength`
    for (let i = 0; i < sequenceLength; i++) {
        let newIndex;
        do {
            newIndex = Math.floor(Math.random() * gridSize * gridSize);
        } while (newIndex === previousIndex); // Ensure the new index is different

        sequence.push(newIndex);
        previousIndex = newIndex; // Update the previous index
    }

    // Update the message
    updateMessage(`Watch!`);

    // Show the sequence
    showSequence(sequence);

    // Check if the current trial completes the round
    if (sequenceLength >= trialsPerRound) {
        sequenceLength = 1; // Reset sequence length for the next level
        saveTaskIIIResult(); // Save results at the end of the round
        showBreakScreen(() => nextLevel()); // Move to the next level
    } else {
        sequenceLength++; // Increase sequence length for the next trial
    }
}




function updateMessage(text) {
    message.textContent = text;
}

let isShowingSequence = false; // Flag to manage input state
let score = 0; // Keep track of the user's score

function showSequence(seq) {
    if (breakMessage.style.display === 'flex') return; // Prevent blinking during break screen

    isShowingSequence = true;
    allowInput = false;
    playerSequence = []; // Clear player's input for the new trial

    // Deactivate all squares before showing the new sequence
    const allSquares = document.querySelectorAll('.square');
    allSquares.forEach(square => square.classList.remove('active'));

    let i = 0;

    const interval = setInterval(() => {
        if (breakMessage.style.display === 'flex') {
            clearInterval(interval); // Stop sequence if break screen is active
            return;
        }

        if (i > 0) deactivateSquare(seq[i - 1]); // Turn off the previous square
        if (i < seq.length) {
            activateSquare(seq[i]); // Turn on the next square
            i++;
        } else {
            clearInterval(interval);
            deactivateSquare(seq[i - 1]); // Turn off the last square
            updateMessage("Go!");
            isShowingSequence = false;
            allowInput = true;

            // Start the 5-second timeout timer
            timeoutTimer = setTimeout(() => {
                allowInput = false;
                checkPlayerSequence(); // Automatically check after timeout
            }, 5000);
        }
    }, 1000);
}


let timeoutTimer; // Timer variable for 5 seconds after 'Go!'
let allowInput = true; // Controls input clicks

function handlePlayerInput(index) {
    if (isShowingSequence || !allowInput) return;

    const square = document.getElementById(`square${index}`);
    square.classList.add('clicked');
    setTimeout(() => square.classList.remove('clicked'), 200);

    playerSequence.push(index);

    // Check only after the user clicks the full sequence length
    if (playerSequence.length === sequence.length) {
        clearTimeout(timeoutTimer); // Stop the timeout timer
        allowInput = false; // Disable further clicks
        checkPlayerSequence();
    }
}




function showBreakScreen(callback) {
    breakMessage.style.display = 'flex';
    let timeRemaining = 5;

    if (level >= 3) {
        // Final message after Round 3
        breakMessage.innerHTML = `<p>Main Tasks Complete! Redirecting to Survey…</p>`;
        timeRemaining = 5;

        const redirectTimer = setInterval(() => {
            timeRemaining--;
            if (timeRemaining === 0) {
                clearInterval(redirectTimer);
                window.location.href = "https://form.jotform.com/243311500343440";
            }
        }, 1000);
    } else {
        // Standard break message for intermediate levels
        breakMessage.innerHTML = `<p>Next round starting in <span id="break-timer">5</span> seconds...</p>`;
        const breakTimerElement = document.getElementById('break-timer');
        breakTimerElement.textContent = timeRemaining;

        const breakTimer = setInterval(() => {
            timeRemaining--;
            breakTimerElement.textContent = timeRemaining;

            if (timeRemaining === 0) {
                clearInterval(breakTimer);
                breakMessage.style.display = 'none';
                callback();
            }
        }, 1000);
    }
}

function nextLevel() {
    level++;
    sequenceLength = 1; // Reset sequence length for the new level

    if (level === 2) {
        gridSize = 4; // Increase grid size for level 2
    } else if (level === 3) {
        gridSize = 5; // Increase grid size for level 3
    } else if (level > 3) {
        // Show final message and redirect to the survey
        showBreakScreen(() => {});
        return;
    }

    sequence = [];
    round++;
    generateGrid(gridSize);
    updateTaskHeader();
    nextRound();
}






            function generateGrid(size) {
                gridContainer.style.gridTemplateColumns = `repeat(${size}, 100px)`;
                gridContainer.style.gridTemplateRows = `repeat(${size}, 100px)`;
                gridContainer.innerHTML = '';

                for (let i = 0; i < size * size; i++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.setAttribute('id', `square${i}`);
                    square.addEventListener('click', () => handlePlayerInput(i));
                    gridContainer.appendChild(square);
                }
            }


// Ensure no error messages or retries; simply keep progressing
function saveTaskIIIResult() {
    const resultData = {
        task: 'Task III',
        level: level,
        roundsCompleted: round - 1,
        score: score, // Record the score
    };

    fetch('/add_task3', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(resultData),
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === "success") {
            console.log('Task III result saved successfully');
        } else {
            console.error('Failed to save Task III result:', data.error);
        }
    })
    .catch((error) => {
        console.error('Error saving Task III result:', error);
    });
}

</script>
        <script>
    document.addEventListener('DOMContentLoaded', () => {
    const infoModal = new bootstrap.Modal(document.getElementById('infoModal'));
    infoModal.show();

    // Handle the "Start Game" button
    document.getElementById('start-task-btn').addEventListener('click', () => {
        infoModal.hide();
        startGame(); // Begin the game
    });
});

 function checkPlayerSequence() {
    let isCorrect = true;

    // Compare player's input with the generated sequence
    for (let i = 0; i < sequence.length; i++) {
        if (playerSequence[i] !== sequence[i]) {
            isCorrect = false;
            break;
        }
    }

    // Show "Correct!" or "Wrong!" message
    if (isCorrect) {
        updateMessage("Correct! 🙂");
    } else {
        updateMessage("Wrong! 🙁");
    }

    // Always move to the next round after showing the message
    setTimeout(() => {
        nextRound(); // Progress to the next round
    }, 1000);

    playerSequence = []; // Reset the player's input
}

</script>

    </body>
{% endblock %}
